// SPDX-FileCopyrightText: 2025 Jo√£o V. Farias (beyondmagic) <beyondmagic@mail.ru>
// SPDX-License-Identifier: AGPL-3.0-or-later

// ------------------------------------------------------------------------
// Types
// ------------------------------------------------------------------------

Enum "TYPE_DOMAIN" {
    "ROUTER" [note: 'Path segment node, like `blog` in `example.com/blog`.']
    "SUBDOMAIN" [note: 'Subdomain node, like `sub` in `sub.example.com`.']
}

Enum "TYPE_STATUS" {
    "PUBLIC" [note: 'Visible/active content or domain.']
    "PRIVATE" [note: 'Hidden content or domain, not publicly accessible.']
    "ARCHIVED" [note: 'Content or domain that is archived but retrievable.']
    "DELETED" [note: 'Content or domain that is deleted and not accessible.']
}

Enum "TYPE_ADAPTER" {
    "HTTP" [note: 'HTTP request/response adapter.']
    "ACTION" [note: 'Internal action/event adapter.']
}

// ------------------------------------------------------------------------
// Area: Auditory
// ------------------------------------------------------------------------

Table "Request" [note: 'Auditing table for tracking content requests (best-effort metadata like IP/device/timestamp).'] {
  "id" serial [pk, not null, increment]
  "id_content" bigint [not null, ref: < "Content"."id", note: 'Content that was requested.']
  "ip" varchar(500) [not null, note: 'Requester IP (best-effort).']
  "device" varchar(500) [not null, note: 'Requester device/user-agent descriptor (best-effort).']
  "time" timestamp [not null, note: 'When the request happened.']
}

// ------------------------------------------------------------------------
// Area: Garden
// ------------------------------------------------------------------------

Table "Garden_Information" [note: 'Localized (per-language) information about a Garden.'] {
  "id" bigint [pk, not null]
  "id_garden" bigint [not null, ref: < "Garden"."id", note: 'Garden being described.']
  "id_language" varchar(500) [not null, ref: < "Language"."id", note: 'Language of this record.']
  "name" varchar(500) [not null, note: 'Garden name in the given language.']
  "description" text [not null, note: 'Garden description in the given language.']

  Indexes {
    (id_garden, id_language) [unique, note: 'One record per garden-language pair.']
  }
}

Table "Garden" [note: 'A garden is a top-level site instance rooted at a Domain node and represented by an Asset (e.g., logo).'] {
  "id" bigint [pk, not null]
  "id_domain" bigint [unique, not null, note: 'Root domain of the garden/platform.', ref: < "Domain"."id"]
  "id_asset" bigint [unique, not null, note: 'Logo/representative asset for the garden.', ref: < "Asset"."id"]
}

// ------------------------------------------------------------------------
// Area: Language
// ------------------------------------------------------------------------

Table "Language_Information" [note: 'Localized (translated) language metadata: a language described in another language.'] {
  "id" bigint [pk, not null]
  "id_for" varchar(500) [not null, ref: < "Language"."id", note: 'Language being described.']
  "id_from" varchar(500) [not null, ref: < "Language"."id", note: 'Language used for the description.']
  "name" varchar(500) [not null, note: 'Localized name of the language.']
  "description" text [not null, note: 'Localized description of the language.']

  Indexes {
    (id_for, id_from) [unique, note: 'One record per language-language pair.']
  }
}

Table "Language" [note: 'Supported languages (e.g., en, pt, ja). Each language may be represented by an Asset (icon/flag).'] {
  "id" varchar(500) [pk, not null]
  "id_asset" bigint [unique, not null, ref: < "Asset"."id", note: 'Representative asset for this language (icon/flag).']
}

// ------------------------------------------------------------------------
// Area: Tag
// ------------------------------------------------------------------------

Table "Tag" [note: 'Tags are labels used for filtering and organizing content/domains. A tag may have a representative Asset.'] {
  "id" bigint [pk, not null]
  "id_asset" bigint [ref: < "Asset"."id", note: 'Optional representative asset for the tag.']
}

Table "Tag_Requirement" [note: 'A tag-to-tag dependency: if id_tag_for is used, id_tag must also be present (e.g. "programming" required for "java").'] {
  "id" bigint [pk, not null]
  "id_tag" bigint [not null, ref: < "Tag"."id", note: 'Required tag.']
  "id_tag_for" bigint [not null, ref: < "Tag"."id", note: 'Tag that requires id_tag.']

  Indexes {
    (id_tag, id_tag_for) [unique, note: 'One requirement per tag-tag pair.']
  }
}

Table "Domain_Tag" [note: 'Associates tags with a domain (for filtering domains by tag).'] {
  "id" bigint [pk, not null]
  "id_domain" bigint [not null, ref: < "Domain"."id", note: 'Tagged domain.']
  "id_tag" bigint [not null, ref: < "Tag"."id", note: 'Tag applied to the domain.']
}

Table "Domain_Asset" [note: 'Associates existing assets with a domain (e.g., a logo.png used by a domain).'] {
  "id" bigint [pk, not null]
  "id_domain" bigint [not null, ref: < "Domain"."id", note: 'Domain using the asset.']
  "id_asset" bigint [not null, ref: < "Asset"."id", note: 'Asset used by the domain.']

  Indexes {
    (id_domain, id_asset) [unique, note: 'One association per domain-asset pair.']
  }
}

Table "Tag_Information" [note: 'Localized (per-language) human-friendly tag name/description.'] {
  "id" bigint [pk, not null]
  "id_tag" bigint [not null, ref: < "Tag"."id", note: 'Tag being described.']
  "id_language" varchar(500) [not null, ref: < "Language"."id", note: 'Language of this record.']
  "name" varchar(500) [not null, note: 'Localized tag name.']
  "description" text [not null, note: 'Localized tag description.']

  Indexes {
    (id_tag, id_language) [unique, note: 'One record per tag-language pair.']
  }
}

// ------------------------------------------------------------------------
// Area: Module
// ------------------------------------------------------------------------

Table "Module" [note: 'Tracks installed modules (repository, version pointers, and enable/disable).'] {
  "id" bigint [pk, not null]
  "repository" varchar(512) [unique, not null, note: 'Repository URL/filepath of the module.']
  "slug" varchar(8) [unique, not null, note: 'Short identifier for the module (used as stable key).']
  "enabled" boolean [not null, note: 'Whether the module is enabled.']
  "last_checked" timestamp [not null, note: 'Last time the server checked this module for updates/health.']
  "commit" varchar(40) [not null, note: 'Current commit hash checked out for this module.']
  "branch" varchar(256) [not null, note: 'Branch tracked for updates (e.g., main).']
}

Table "Module_Binding" [note: 'Binds a module capability to a garden/domain-tree scope (routing/dispatch configuration).'] {
  "id" bigint [pk, not null]
  "id_garden" bigint [not null, ref: < "Garden"."id", note: 'Garden that owns this binding.']

  "id_domain_target" bigint [ref: < "Domain"."id", note: 'Optional target domain. NULL means garden-wide binding.']

  "adapter" TYPE_ADAPTER [not null, note: 'Adapter type of the capability being bound (HTTP vs ACTION).']

  "recursive" boolean [not null, note: 'If true, applies to descendant domains under the target.']
  "enabled" boolean [not null, note: 'Whether this binding participates in dispatch.']

  "slug_module" varchar(8) [not null, ref: < "Module"."slug", note: 'Module providing the capability.']
  "slug_capability" varchar(8) [not null, note: 'Capability identifier within the module.']

  "methods" varchar(128) [note: 'Optional allow-list of HTTP methods (e.g. "GET,POST"); NULL means all.']

  "priority" int [not null, default: 0, note: 'Tie-breaker when multiple bindings match; higher wins.']

  Indexes {
    (id_garden, enabled) [note: 'Index to quickly find enabled/disabled bindings within a garden.']
    (id_garden, id_domain_target) [note: 'Index to quickly find bindings for a specific garden-domain pair.']
    (id_garden, slug_module) [note: 'Index to quickly find bindings for a specific garden-module pair.']
    (id_garden, id_domain_target, slug_module, slug_capability) [unique, note: 'Unique constraint to prevent duplicate bindings for the same garden, target domain, module, and capability.']
  }
}

// ------------------------------------------------------------------------
// Area: Domain
// ------------------------------------------------------------------------

Table "Domain" [note: 'Domain tree node used for both SUBDOMAIN (host labels) and ROUTER (path segments).'] {
  "id" bigint [pk, not null]
  "id_domain_parent" bigint [ref: < "Domain"."id", note: 'Parent domain node (if any).']
  "id_domain_redirect" bigint [ref: < "Domain"."id", note: 'Optional redirect target for this domain.']
  "type" TYPE_DOMAIN [not null, note: 'ROUTER or SUBDOMAIN.']
  "name" varchar(500) [not null, note: 'Label for this node (subdomain label or router segment).']
  "status" TYPE_STATUS [not null, note: 'Visibility/lifecycle state of this node.']

  Indexes {
    (id_domain_parent, type, name) [unique, note: 'Unique constraint to prevent duplicate subdomains/routes under the same parent.']
  }
}

Table "Content" [note: 'Content entries belonging to a domain and language (e.g., blog post/page).'] {
  "id" bigint [pk, not null]
  "id_domain" bigint [not null, ref: < "Domain"."id", note: 'Domain that owns this content.']
  "id_language" varchar(500) [not null, ref: < "Language"."id", note: 'Language of the content.']
  "status" TYPE_STATUS [not null, note: 'Visibility/lifecycle state.']
  "title" varchar(500) [note: 'Title (required in current SQL implementation).']
  "title_sub" varchar(500) [note: 'Subtitle (required in current SQL implementation).']
  "synopsis" varchar(500) [note: 'Short summary (required in current SQL implementation).']
  "body" text [note: 'Main content body (required in current SQL implementation).']
  "requests" bigint [not null, note: 'Denormalized counter for request/visit tracking (if used).']

  Indexes {
    (id_domain, id_language) [unique, note: 'One content entry per domain-language pair.']
  }
}

Table "Content_Link" [note: 'Directed links between content entries (for graphs/backlinks).'] {
  "id" bigint [pk, not null]
  "id_from" bigint [not null, ref: < "Content"."id", note: 'Source content.']
  "id_to" bigint [not null, ref: < "Content"."id", note: 'Destination content.']

  Indexes {
    (id_from, id_to) [unique, note: 'One link per content-content pair.']
  }
}

// ------------------------------------------------------------------------
// Area: Asset
// ------------------------------------------------------------------------

Table "Asset" [note: 'Assets are files such as images, scripts, videos. Used as logos/icons and general media.'] {
  "id" bigint [pk, not null]
  "id_domain" bigint [unique, not null, ref: < "Domain"."id", note: 'Domain that owns the asset (often an asset subtree).']
  "name" varchar(500) [unique, not null, note: 'Asset filename (Linux allows up to 4096 bytes).']
  "extension" varchar(500) [note: 'Optional file extension (e.g. .png, .jpg, .js).']
}

Table "Asset_Information" [note: 'Localized (per-language) asset name/description.'] {
  "id" bigint [pk, not null]
  "id_asset" bigint [not null, ref: < "Asset"."id", note: 'Asset being described.']
  "id_language" varchar(500) [not null, ref: < "Language"."id", note: 'Language of this record.']
  "name" varchar(500) [not null, note: 'Localized asset name.']
  "description" text [not null, note: 'Localized asset description.']

  Indexes {
    (id_asset, id_language) [unique, note: 'One record per asset-language pair.']
  }
}

// ------------------------------------------------------------------------
// Area: Authors
// ------------------------------------------------------------------------

Table "Author" [note: 'Authors/users who can own domains and content. Stores identity + hashed password and counters.'] {
  "id" bigint [pk, not null]
  "id_asset" bigint [not null, ref: < "Asset"."id", note: 'Profile picture asset.']
  "email" varchar(500) [unique, not null, note: 'Unique author email.']
  "name" varchar(500) [not null, note: 'Display name.']
  "password" varchar(500) [not null, note: 'Hashed password; never store plaintext.']
  "pages" bigint [not null, note: 'Counter: number of domains/pages created by the author.']
  "contents" bigint [not null, note: 'Counter: number of content entries created by the author.']
}

Table "Author_Connections" [note: 'Stores active/previous author sessions (device + token + timestamps).'] {
  "id" bigint [pk, not null]
  "id_author" bigint [not null, ref: < "Author"."id", note: 'Author owning the connection/session.']
  "device" varchar(500) [not null, note: 'Device identifier/label.']
  "token" varchar(500) [unique, not null, note: 'Session token presented by the client.']
  "logged_at" timestamp [not null, note: 'When the session was created.']
  "last_connection" timestamp [not null, note: 'Last time this token was used.']
}

Table "Authored_Domain" [note: 'Many-to-many: which authors control which domains.'] {
  "id" bigint [pk, not null]
  "id_author" bigint [not null, ref: < "Author"."id", note: 'Author with control.']
  "id_domain" bigint [not null, ref: < "Domain"."id", note: 'Controlled domain.']

  Indexes {
    (id_author, id_domain) [unique, note: 'One record per author-domain pair.']
  }
}

Table "Authored_Content" [note: 'Many-to-many: which authors control which content entries.'] {
  "id" bigint [pk, not null]
  "id_author" bigint [not null, ref: < "Author"."id", note: 'Author with control.']
  "id_content" bigint [not null, ref: < "Content"."id", note: 'Controlled content.']

  Indexes {
    (id_author, id_content) [unique, note: 'One record per author-content pair.']
  }
}

Table "Authored_Garden" [note: 'Many-to-many: which authors have admin/control over a garden.'] {
  "id" bigint [pk, not null]
  "id_author" bigint [not null, ref: < "Author"."id", note: 'Author with control.']
  "id_garden" bigint [not null, ref: < "Garden"."id", note: 'Controlled garden.']
  Indexes {
     (id_author, id_garden) [unique, note: 'One record per author-garden pair.']
  }
}
